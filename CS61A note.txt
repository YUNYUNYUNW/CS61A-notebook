''''''''''


'''

'''''''''def welcome():
    print('Go')
    return 'hello'
def cal():
    print('Bears')
    return 'world'
welcome()
print(welcome()
print(welcome(),cal())'''''''''

'''def sums_print(n):
    print(n)
    def next_sum(k):
        return sums_print(n + k)
    return next_sum

sums_print(3)(5)(7)'''
'''def digit_all_caul(n):
    all_but_last , last = n // 10 , n % 10
    if n >= 10:
        return digit_all_caul(all_but_last) + last
    else:
        return n

print(digit_all_caul(139))'''
'''def recursive_function_print(n):
    if n < 10:
        print(n)
    else:
        print(n)
        recursive_function_print(n//10)
        print(n)
recursive_function_print(1234)

'''
'''write a function that print inverse cascade'''
'''result = []
def substract(m):


    if m < 10:
        result.append(m)
        return result
    else:
        result.append(m)
        substract(m//10)

        return result


ah = substract(1234)
print(ah)
ah_wise = sorted(ah)
ah_antiwise = sorted(ah,reverse = True)
ah_antiwise.(1)
for number in ah_wise:
    print(number)
for number in ah_antiwise:
    print(number)
'''
'''def inverse_cascade(n):
    grow(n)
    print(n)
    shrink(n)
def f_then_g(f,g,n):
    if n:
        f(n)
        g(n)
grow = lambda n : f_then_g(grow, print , n//10)
shrink = lambda n : f_then_g(print , shrink , n//10)

inverse_cascade(1234)
'''
'''Tree recursion'''
'''from ucb import trace
@trace
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
print(fibonacci(5))'''
'''counting partitions'''
'''counting the partitions of integer.'''
'''def partitions_counting(n , m):
    if n == 0:
        return 1
    elif m == 0:
        return 0
    elif n < 0:
        return 0
    else:
        with_m = partitions_counting(n-m , m)
        without_m = partitions_counting(n , m-1)
        return with_m + without_m
print(partitions_counting(6,4))
'''
'''from operator import add
ah = [2 , 7 , 1 , 8 , 3]'''
'''def count(s,ah):
    total = 0
    length = len(ah)
    for element in ah:
        if element == s:
            total += 1
    return total
print(count(1,[1,2,3,1,1]))'''
'''ah = [[1,2] , [1,3] , [1,4] , [2,4]]
total = 0
for x,y in ah:
    if x - y == -1:
        total += 1
print(total)
'''
'''print(list(range(1,3)))'''
'''ah = [1 , 3, 5 ,7 ,9]
ah = [x+1 for x in ah]
print(ah)'''
'''def divisor_find(n):
    return [1] + [x for x in range(2,n) if n%x == 0]
print(divisor_find(12))'''
'''slice application'''
'''def sum_digits(s):
    if len(s) == 0:
        return 0
    else:
        return s[0] + sum_digits(s[1:])
print(sum_digits([1,2,3,4]))'''
'''return the sublist of positive integer s with the largest sum that is less than n'''
'''def sum_list(s):
    if s == []:
        return 0
    else:
        return sum(s)

def sublist(s , n):
    if s == []:
        return []
    elif s[0] > n:
        return sublist(s[1:] , n)
    else:
        with_s0 = [s[0]]+ sublist(s[1:] , n - s[0])
        without_s0 = sublist(s[1:] , n)
        if sum_list(with_s0) > sum_list(without_s0):
            return with_s0
        else:
            return without_s0
print(sublist([4,2,5,6,7],20))'''
'''ah = [1,2,3,4,5]
print(sum([[1,3],[2,4]],[]))'''
'''sum has a start (iterable, start)'''
'''max takes two forms max(iterable , key = function)'''

'''ah = [1,2,3]
min_value = min(ah , key = lambda x :pow(x,2) - 4 * x)
print(min_value)'''
'''all(iterable)'''
'''print(all(range(1,5)))'''
'''from operator import add,mul
exec('curry = lambda f,x,y : f(x,y)')
print(curry)
print(curry(add,2,3))'''
'''print(" backslash means excaping the character itself
wdsdwdsdwdwd
sdawdawdasdawd")'''
'''print("microsoft is a fantanstic company\nwhile its chief is smart and ambitious")'''
'''dict = {'I':[123],'G':1}
print(dict.values())'''
'''dictionary comprehensions:'''
'''print({x*x:x**3 for x in [1,2,3,4,5,6] if x % 2 == 0})'''
'''import random
min_sum = 0
n = 1
while 1 :
    a = random.random()
    b = random.random()
    c = 1 - a - b
    if a > 0 and b > 0 and c > 0:
        n += 1
        min_sum += min(a,b,c)
    print(min_sum/n)
'''
'''match function'''
'''def index(key,values,match):
    return {k : [x for x in values if match(x,k)] for  k in key}
def division(m,n):
    if m % n == 0:
        return 1
    if m % n != 0:
        return 0
print(index([5,7,9] , range(1,60) , division))'''

'''DATA ABSTRACTION'''
'''from operator import getitem
pair = [1,2]
print(getitem(pair,0))'''
'''rational data abstraction'''
'''def rational(n,d):
    return [n,d]
'''
''''''
def trees(label,branch = []):
    return [label] + list(branch)
T = trees(1,[trees(1),trees(2,[trees(1),trees(0)])])
def branches(tree):
    return tree[1:]
def check(tree):
    if tree == [] or type(tree) != list:
        return False
    for branch in branches(tree):
        if not check(branch):
            return False
    return True
def is_leaf(tree):
    return branches(tree) == []
print('the return value of is_leaf:',is_leaf([5]))
'''count_leaves implementation:'''
def count_leaves(t):
    if is_leaf(t):
        return 1
    else:
        return sum([count_leaves(b) for b in branches(t)])
print('vount_leaves of T:',count_leaves(T))
'''result = []'''
def label(tree):
    return tree[0]
def leaves_print(t):
    if is_leaf(t):
        return t #[label(t)]
    else:
        return sum([leaves_print(b) for b in branches(t)],[])
print(leaves_print(T))

def fib_tree(n):
    if n<= 1:
        return trees(n)
    else:
        left , right = fib_tree(n-1) , fib_tree(n-2)
        return trees(label(left) + label(right) , [left,right])
print(fib_tree(4))
count_leave = 0
def count_leaves(tree):
    if len(tree) == 1:
        return 1
    else:
        for branch in branches(tree):
            return sum([count_leaves(branch) for branch in branches(tree)])
expe = [1]
print(count_leaves(expe))
def tree_increment(t):
    if is_leaf(t):
        return trees(label(t) + 1)
    else:
        bs = [tree_increment(w) for w in branches(t)]
        return trees(label(t),bs)
'''print(tree_increment([3, [2, [1, [1], [0]], [1]], [1, [1], [0]]]))'''
def print_indent_tree(t , indent = 0):
    print(' ' * indent + str(label(t)))
    for b in branches(t):
        print_indent_tree(b , indent + 1)
def find_all_leaves(tree):
    if is_leaf(tree):
        return trees(label(tree))
    else:
        return sum([find_all_leaves(b) for b in branches(tree)],[])
'''print(find_all_leaves([3, [2, [1, [1], [0]], [1]], [1, [1], [0]]]))'''
def print_sums(tree , so_far = 0):
    so_far += label(tree)
    if is_leaf(tree):
        return so_far
    else:
        return so_far + sum([print_sums(b) for b in branches(tree)])
'''print(print_sums([3, [2, [1, [1], [0]], [1]], [1, [1], [0]]]))'''
def print_each_sums(tree , so_far = 0):
    so_far += label(tree)
    if is_leaf(tree):
        print(so_far)
    else:
        for b in branches(tree):
            print_each_sums(b , so_far)
'''print_each_sums([3, [2, [1, [1], [0]], [1]], [1, [1], [0]]])'''
def count_paths(tree , total):
    if label(tree) == total:
        found = 1
    else:
        found = 0
    return found + sum([count_paths(b , total - label(tree)) for b in branches(tree)])
'''print(count_paths(trees(3,[trees(2,[trees(1)]),trees(3,[trees(1),trees(2)])]),5))'''
print((trees(3,[trees(2,[trees(1)]),trees(3,[trees(1),trees(2)])])))
'''objects '''
'attribute of objects, methonds'
from datetime import date
today = date(2015 , 2 , 15)
print(today.month)

'''a = 10
b = a
a += 2
print(b)'''
'''mutable functions created by a mutable value:'''
'''def make_withdraw_list(balance):
    b = [balance]
    def withdraw(amount):
        if b[0] < amount:
            return 'Insufficient funds'
        else:
            b[0] = b[0] - amount
            return b[0]
    return withdraw
withdraw = make_withdraw_list(100)
print(withdraw(125))
'''
'''def total_remove(s,element):
    if element in s:
        s.remove(element)
        return total_remove(s , element)
    else:
        print(s)
        return s
total_remove([1,2,3,1,2,3,1,2,3] , 1)'''
'''iterator and iterable'''
'''s = [1,2,3,4]
t = iter(s)
print(next(t))'''
'''d = {'one':1 , 'two':2 , 'three':3 , 'four':4}
d['other'] = 5
s = iter(d.keys())
print(next(s))
print(next(s))
s = iter(d.values())
print(next(s))
s = iter(d.items())
print(next(s))'''
'''by default, while s = iter(s) if I change the dictionary, it would error! Just recreate a new iterator'''
'''print(list(range(3,6)))'''
'''built-in iterable functions '''
'''bcd = ['b','c','d']
b = map(lambda x : x.upper() , bcd)
print(next(b))
'''
'''print(list(zip([1,2] , [3,4] , [5,6])))'''

